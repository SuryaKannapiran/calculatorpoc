{"ast":null,"code":"// Function to evaluate pricing formulas safely\nexport const evaluateFormula = (formula, variables, includedQuotas = {}) => {\n  try {\n    // Replace variables in the formula with their values\n    let evaluatedFormula = formula;\n\n    // Replace unit variables\n    Object.keys(variables).forEach(key => {\n      const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n      evaluatedFormula = evaluatedFormula.replace(regex, variables[key]);\n    });\n\n    // Replace included_quotas references\n    Object.keys(includedQuotas).forEach(quotaKey => {\n      const quota = includedQuotas[quotaKey];\n      const quotaValueRegex = new RegExp(`included_quotas\\\\.${quotaKey}\\\\.value`, 'g');\n      evaluatedFormula = evaluatedFormula.replace(quotaValueRegex, quota.value);\n    });\n\n    // Create a safe evaluation context with only allowed functions\n    const safeEval = expr => {\n      // Only allow basic mathematical operations and Math functions\n      const allowedFunctions = ['Math.max', 'Math.min', 'Math.round', 'Math.floor', 'Math.ceil', 'max', 'min'];\n      const allowedOperators = ['+', '-', '*', '/', '(', ')', '.', ' '];\n\n      // Basic validation - you might want to add more sophisticated validation\n      const hasOnlyAllowedChars = /^[0-9+\\-*/().\\s,]+$/.test(expr) || allowedFunctions.some(func => expr.includes(func));\n      if (!hasOnlyAllowedChars) {\n        throw new Error('Invalid characters in formula');\n      }\n\n      // Use Function constructor for safer evaluation with max/min functions\n      return new Function('Math', 'max', 'min', `return ${expr}`)(Math, Math.max, Math.min);\n    };\n    return safeEval(evaluatedFormula);\n  } catch (error) {\n    console.error('Error evaluating formula:', error);\n    return 0;\n  }\n};\n\n// Calculate price for any pricing entity (plan or addon)\nexport const calculateEntityPrice = (entity, units) => {\n  const variables = {\n    unit: units,\n    unit_price: parseFloat(entity.unit_price)\n  };\n\n  // Handle different unit names in formulas\n  if (entity.unit === 'seat') {\n    variables.seat = units;\n  } else if (entity.unit === 'resolution') {\n    variables.resolution = units;\n  } else {\n    variables[entity.unit] = units;\n  }\n  return evaluateFormula(entity.formula, variables, entity.included_quotas);\n};\n\n// Calculate total price including all selected addons\nexport const calculateTotalPrice = (selectedPlan, addons, planUnits, addonUnits) => {\n  let total = calculateEntityPrice(selectedPlan, planUnits[selectedPlan.id] || 0);\n  addons.forEach(addon => {\n    if (addonUnits[addon.id] && addonUnits[addon.id] > 0) {\n      total += calculateEntityPrice(addon, addonUnits[addon.id]);\n    }\n  });\n  return total;\n};\n\n// Get available addons for a specific plan\nexport const getAvailableAddons = (plan, allAddons) => {\n  return allAddons.filter(addon => plan.available_addons && plan.available_addons.includes(addon.id));\n};\n\n// Validate pricing data against schema\nexport const validatePricingData = data => {\n  const requiredFields = ['vendor', 'url', 'currency', 'plans', 'addons'];\n  const missingFields = requiredFields.filter(field => !data[field]);\n  if (missingFields.length > 0) {\n    throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n  }\n  if (!Array.isArray(data.plans) || data.plans.length === 0) {\n    throw new Error('At least one plan is required');\n  }\n\n  // Validate each plan\n  data.plans.forEach((plan, index) => {\n    const planRequiredFields = ['id', 'label', 'description', 'unit', 'unit_price', 'pricing_model', 'features', 'formula'];\n    const missingPlanFields = planRequiredFields.filter(field => !plan[field]);\n    if (missingPlanFields.length > 0) {\n      throw new Error(`Plan ${index + 1} missing required fields: ${missingPlanFields.join(', ')}`);\n    }\n  });\n\n  // Validate each addon\n  data.addons.forEach((addon, index) => {\n    const addonRequiredFields = ['id', 'label', 'description', 'unit', 'unit_price', 'pricing_model', 'features', 'formula'];\n    const missingAddonFields = addonRequiredFields.filter(field => !addon[field]);\n    if (missingAddonFields.length > 0) {\n      throw new Error(`Addon ${index + 1} missing required fields: ${missingAddonFields.join(', ')}`);\n    }\n  });\n  return true;\n};\n\n// Get default slider ranges based on pricing model and included quotas\nexport const getSliderRange = entity => {\n  const baseRange = {\n    min: 0,\n    max: 100,\n    step: 1\n  };\n\n  // Adjust range based on included quotas\n  if (entity.included_quotas) {\n    const quotaKey = Object.keys(entity.included_quotas)[0];\n    if (quotaKey && entity.included_quotas[quotaKey]) {\n      const quotaValue = parseInt(entity.included_quotas[quotaKey].value) || 0;\n      baseRange.min = Math.max(0, quotaValue); // Start from included quota\n      baseRange.max = Math.max(100, quotaValue + 50); // Extend range\n    }\n  }\n  switch (entity.pricing_model) {\n    case 'per_unit':\n      return baseRange;\n    case 'flat':\n      return {\n        min: 0,\n        max: 1,\n        step: 1\n      };\n    case 'tiered':\n      return {\n        min: 1,\n        max: 10,\n        step: 1\n      };\n    default:\n      return baseRange;\n  }\n};\n\n// Format currency based on the provided currency code\nexport const formatCurrency = (amount, currency = 'USD') => {\n  const currencySymbols = {\n    'USD': '$',\n    'EUR': '€',\n    'GBP': '£',\n    'JPY': '¥',\n    'CAD': 'C$',\n    'AUD': 'A$'\n  };\n  const symbol = currencySymbols[currency] || currency;\n  return `${symbol}${amount.toFixed(2)}`;\n};\n\n// Get included quota information for display\nexport const getIncludedQuotaInfo = entity => {\n  if (!entity.included_quotas) return null;\n  const quotaKey = Object.keys(entity.included_quotas)[0];\n  if (quotaKey && entity.included_quotas[quotaKey]) {\n    const quota = entity.included_quotas[quotaKey];\n    return {\n      value: parseInt(quota.value) || 0,\n      unit: quota.unit || entity.unit\n    };\n  }\n  return null;\n};","map":{"version":3,"names":["evaluateFormula","formula","variables","includedQuotas","evaluatedFormula","Object","keys","forEach","key","regex","RegExp","replace","quotaKey","quota","quotaValueRegex","value","safeEval","expr","allowedFunctions","allowedOperators","hasOnlyAllowedChars","test","some","func","includes","Error","Function","Math","max","min","error","console","calculateEntityPrice","entity","units","unit","unit_price","parseFloat","seat","resolution","included_quotas","calculateTotalPrice","selectedPlan","addons","planUnits","addonUnits","total","id","addon","getAvailableAddons","plan","allAddons","filter","available_addons","validatePricingData","data","requiredFields","missingFields","field","length","join","Array","isArray","plans","index","planRequiredFields","missingPlanFields","addonRequiredFields","missingAddonFields","getSliderRange","baseRange","step","quotaValue","parseInt","pricing_model","formatCurrency","amount","currency","currencySymbols","symbol","toFixed","getIncludedQuotaInfo"],"sources":["/Users/cb-surya/work/personal_poc/calculatorpoc/src/utils/calculator.js"],"sourcesContent":["// Function to evaluate pricing formulas safely\nexport const evaluateFormula = (formula, variables, includedQuotas = {}) => {\n  try {\n    // Replace variables in the formula with their values\n    let evaluatedFormula = formula;\n    \n    // Replace unit variables\n    Object.keys(variables).forEach(key => {\n      const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n      evaluatedFormula = evaluatedFormula.replace(regex, variables[key]);\n    });\n    \n    // Replace included_quotas references\n    Object.keys(includedQuotas).forEach(quotaKey => {\n      const quota = includedQuotas[quotaKey];\n      const quotaValueRegex = new RegExp(`included_quotas\\\\.${quotaKey}\\\\.value`, 'g');\n      evaluatedFormula = evaluatedFormula.replace(quotaValueRegex, quota.value);\n    });\n    \n    // Create a safe evaluation context with only allowed functions\n    const safeEval = (expr) => {\n      // Only allow basic mathematical operations and Math functions\n      const allowedFunctions = ['Math.max', 'Math.min', 'Math.round', 'Math.floor', 'Math.ceil', 'max', 'min'];\n      const allowedOperators = ['+', '-', '*', '/', '(', ')', '.', ' '];\n      \n      // Basic validation - you might want to add more sophisticated validation\n      const hasOnlyAllowedChars = /^[0-9+\\-*/().\\s,]+$/.test(expr) || \n                                 allowedFunctions.some(func => expr.includes(func));\n      \n      if (!hasOnlyAllowedChars) {\n        throw new Error('Invalid characters in formula');\n      }\n      \n      // Use Function constructor for safer evaluation with max/min functions\n      return new Function('Math', 'max', 'min', `return ${expr}`)(\n        Math, \n        Math.max, \n        Math.min\n      );\n    };\n    \n    return safeEval(evaluatedFormula);\n  } catch (error) {\n    console.error('Error evaluating formula:', error);\n    return 0;\n  }\n};\n\n// Calculate price for any pricing entity (plan or addon)\nexport const calculateEntityPrice = (entity, units) => {\n  const variables = {\n    unit: units,\n    unit_price: parseFloat(entity.unit_price)\n  };\n  \n  // Handle different unit names in formulas\n  if (entity.unit === 'seat') {\n    variables.seat = units;\n  } else if (entity.unit === 'resolution') {\n    variables.resolution = units;\n  } else {\n    variables[entity.unit] = units;\n  }\n  \n  return evaluateFormula(entity.formula, variables, entity.included_quotas);\n};\n\n// Calculate total price including all selected addons\nexport const calculateTotalPrice = (selectedPlan, addons, planUnits, addonUnits) => {\n  let total = calculateEntityPrice(selectedPlan, planUnits[selectedPlan.id] || 0);\n  \n  addons.forEach(addon => {\n    if (addonUnits[addon.id] && addonUnits[addon.id] > 0) {\n      total += calculateEntityPrice(addon, addonUnits[addon.id]);\n    }\n  });\n  \n  return total;\n};\n\n// Get available addons for a specific plan\nexport const getAvailableAddons = (plan, allAddons) => {\n  return allAddons.filter(addon => \n    plan.available_addons && plan.available_addons.includes(addon.id)\n  );\n};\n\n// Validate pricing data against schema\nexport const validatePricingData = (data) => {\n  const requiredFields = ['vendor', 'url', 'currency', 'plans', 'addons'];\n  const missingFields = requiredFields.filter(field => !data[field]);\n  \n  if (missingFields.length > 0) {\n    throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n  }\n  \n  if (!Array.isArray(data.plans) || data.plans.length === 0) {\n    throw new Error('At least one plan is required');\n  }\n  \n  // Validate each plan\n  data.plans.forEach((plan, index) => {\n    const planRequiredFields = ['id', 'label', 'description', 'unit', 'unit_price', 'pricing_model', 'features', 'formula'];\n    const missingPlanFields = planRequiredFields.filter(field => !plan[field]);\n    \n    if (missingPlanFields.length > 0) {\n      throw new Error(`Plan ${index + 1} missing required fields: ${missingPlanFields.join(', ')}`);\n    }\n  });\n  \n  // Validate each addon\n  data.addons.forEach((addon, index) => {\n    const addonRequiredFields = ['id', 'label', 'description', 'unit', 'unit_price', 'pricing_model', 'features', 'formula'];\n    const missingAddonFields = addonRequiredFields.filter(field => !addon[field]);\n    \n    if (missingAddonFields.length > 0) {\n      throw new Error(`Addon ${index + 1} missing required fields: ${missingAddonFields.join(', ')}`);\n    }\n  });\n  \n  return true;\n};\n\n// Get default slider ranges based on pricing model and included quotas\nexport const getSliderRange = (entity) => {\n  const baseRange = { min: 0, max: 100, step: 1 };\n  \n  // Adjust range based on included quotas\n  if (entity.included_quotas) {\n    const quotaKey = Object.keys(entity.included_quotas)[0];\n    if (quotaKey && entity.included_quotas[quotaKey]) {\n      const quotaValue = parseInt(entity.included_quotas[quotaKey].value) || 0;\n      baseRange.min = Math.max(0, quotaValue); // Start from included quota\n      baseRange.max = Math.max(100, quotaValue + 50); // Extend range\n    }\n  }\n  \n  switch (entity.pricing_model) {\n    case 'per_unit':\n      return baseRange;\n    case 'flat':\n      return { min: 0, max: 1, step: 1 };\n    case 'tiered':\n      return { min: 1, max: 10, step: 1 };\n    default:\n      return baseRange;\n  }\n};\n\n// Format currency based on the provided currency code\nexport const formatCurrency = (amount, currency = 'USD') => {\n  const currencySymbols = {\n    'USD': '$',\n    'EUR': '€',\n    'GBP': '£',\n    'JPY': '¥',\n    'CAD': 'C$',\n    'AUD': 'A$'\n  };\n  \n  const symbol = currencySymbols[currency] || currency;\n  return `${symbol}${amount.toFixed(2)}`;\n};\n\n// Get included quota information for display\nexport const getIncludedQuotaInfo = (entity) => {\n  if (!entity.included_quotas) return null;\n  \n  const quotaKey = Object.keys(entity.included_quotas)[0];\n  if (quotaKey && entity.included_quotas[quotaKey]) {\n    const quota = entity.included_quotas[quotaKey];\n    return {\n      value: parseInt(quota.value) || 0,\n      unit: quota.unit || entity.unit\n    };\n  }\n  \n  return null;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}