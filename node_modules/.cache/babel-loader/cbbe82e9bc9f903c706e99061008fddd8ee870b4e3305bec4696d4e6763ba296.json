{"ast":null,"code":"// Function to evaluate pricing formulas safely\nexport const evaluateFormula = (formula, variables, includedQuotas = {}) => {\n  try {\n    const scope = {\n      ...variables,\n      included_quotas: {},\n      max: Math.max,\n      min: Math.min,\n      Math: Math // for other Math functions\n    };\n\n    // Populate included_quotas in the scope\n    Object.keys(includedQuotas).forEach(quotaKey => {\n      scope.included_quotas[quotaKey] = {\n        value: parseInt(includedQuotas[quotaKey].value, 10)\n      };\n    });\n    const varNames = Object.keys(scope);\n    const varValues = Object.values(scope);\n    const func = new Function(...varNames, `return ${formula};`);\n    return func(...varValues);\n  } catch (error) {\n    console.error('Error evaluating formula:', {\n      formula,\n      variables,\n      includedQuotas,\n      error\n    });\n    return 0;\n  }\n};\n\n// Calculate price for any pricing entity (plan or addon)\nexport const calculateEntityPrice = (entity, units) => {\n  // If no units are selected, the price is 0.\n  if (units === 0) {\n    return 0;\n  }\n  const variables = {\n    unit: units,\n    unit_price: parseFloat(entity.unit_price)\n  };\n\n  // The formula might use a specific name for the unit, like 'seat' or 'resolution'\n  variables[entity.unit] = units;\n  return evaluateFormula(entity.formula, variables, entity.included_quotas);\n};\n\n// Calculate total price including all selected addons\nexport const calculateTotalPrice = (selectedPlan, addons, planUnits, addonUnits) => {\n  let total = calculateEntityPrice(selectedPlan, planUnits[selectedPlan.id] || 0);\n  addons.forEach(addon => {\n    if (addonUnits[addon.id] && addonUnits[addon.id] > 0) {\n      total += calculateEntityPrice(addon, addonUnits[addon.id]);\n    }\n  });\n  return total;\n};\n\n// Get available addons for a specific plan\nexport const getAvailableAddons = (plan, allAddons) => {\n  return allAddons.filter(addon => plan.available_addons && plan.available_addons.includes(addon.id));\n};\n\n// Validate pricing data against schema\nexport const validatePricingData = data => {\n  const requiredFields = ['vendor', 'url', 'currency', 'plans', 'addons'];\n  const missingFields = requiredFields.filter(field => !data[field]);\n  if (missingFields.length > 0) {\n    throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n  }\n  if (!Array.isArray(data.plans) || data.plans.length === 0) {\n    throw new Error('At least one plan is required');\n  }\n\n  // Validate each plan\n  data.plans.forEach((plan, index) => {\n    const planRequiredFields = ['id', 'label', 'description', 'unit', 'unit_price', 'pricing_model', 'features', 'formula'];\n    const missingPlanFields = planRequiredFields.filter(field => !plan[field]);\n    if (missingPlanFields.length > 0) {\n      throw new Error(`Plan ${index + 1} missing required fields: ${missingPlanFields.join(', ')}`);\n    }\n  });\n\n  // Validate each addon\n  data.addons.forEach((addon, index) => {\n    const addonRequiredFields = ['id', 'label', 'description', 'unit', 'unit_price', 'pricing_model', 'features', 'formula'];\n    const missingAddonFields = addonRequiredFields.filter(field => !addon[field]);\n    if (missingAddonFields.length > 0) {\n      throw new Error(`Addon ${index + 1} missing required fields: ${missingAddonFields.join(', ')}`);\n    }\n  });\n  return true;\n};\n\n// Get default slider ranges based on pricing model and included quotas\nexport const getSliderRange = entity => {\n  const baseRange = {\n    min: 0,\n    max: 100,\n    step: 1\n  };\n\n  // Adjust range based on included quotas\n  if (entity.included_quotas) {\n    const quotaKey = Object.keys(entity.included_quotas)[0];\n    if (quotaKey && entity.included_quotas[quotaKey]) {\n      const quotaValue = parseInt(entity.included_quotas[quotaKey].value) || 0;\n      baseRange.max = Math.max(100, quotaValue + 50); // Extend range\n    }\n  }\n  switch (entity.pricing_model) {\n    case 'per_unit':\n      return baseRange;\n    case 'flat':\n      return {\n        min: 0,\n        max: 1,\n        step: 1\n      };\n    case 'tiered':\n      return {\n        min: 1,\n        max: 10,\n        step: 1\n      };\n    default:\n      return baseRange;\n  }\n};\n\n// Format currency based on the provided currency code\nexport const formatCurrency = (amount, currency = 'USD') => {\n  const currencySymbols = {\n    'USD': '$',\n    'EUR': '€',\n    'GBP': '£',\n    'JPY': '¥',\n    'CAD': 'C$',\n    'AUD': 'A$'\n  };\n  const symbol = currencySymbols[currency] || currency;\n  return `${symbol}${amount.toFixed(2)}`;\n};\n\n// Get included quota information for display\nexport const getIncludedQuotaInfo = entity => {\n  if (!entity.included_quotas) return null;\n  const quotaKey = Object.keys(entity.included_quotas)[0];\n  if (quotaKey && entity.included_quotas[quotaKey]) {\n    const quota = entity.included_quotas[quotaKey];\n    return {\n      value: parseInt(quota.value) || 0,\n      unit: quota.unit || entity.unit\n    };\n  }\n  return null;\n};\n\n// Check if current value is at the included quota level\nexport const isAtIncludedQuota = (entity, currentValue) => {\n  const quotaInfo = getIncludedQuotaInfo(entity);\n  if (!quotaInfo) return false;\n  return currentValue <= quotaInfo.value;\n};","map":{"version":3,"names":["evaluateFormula","formula","variables","includedQuotas","scope","included_quotas","max","Math","min","Object","keys","forEach","quotaKey","value","parseInt","varNames","varValues","values","func","Function","error","console","calculateEntityPrice","entity","units","unit","unit_price","parseFloat","calculateTotalPrice","selectedPlan","addons","planUnits","addonUnits","total","id","addon","getAvailableAddons","plan","allAddons","filter","available_addons","includes","validatePricingData","data","requiredFields","missingFields","field","length","Error","join","Array","isArray","plans","index","planRequiredFields","missingPlanFields","addonRequiredFields","missingAddonFields","getSliderRange","baseRange","step","quotaValue","pricing_model","formatCurrency","amount","currency","currencySymbols","symbol","toFixed","getIncludedQuotaInfo","quota","isAtIncludedQuota","currentValue","quotaInfo"],"sources":["/Users/cb-surya/work/personal_poc/calculatorpoc/src/packages/calculator/utils/calculator.js"],"sourcesContent":["// Function to evaluate pricing formulas safely\nexport const evaluateFormula = (formula, variables, includedQuotas = {}) => {\n  try {\n    const scope = {\n      ...variables,\n      included_quotas: {},\n      max: Math.max,\n      min: Math.min,\n      Math: Math // for other Math functions\n    };\n\n    // Populate included_quotas in the scope\n    Object.keys(includedQuotas).forEach(quotaKey => {\n      scope.included_quotas[quotaKey] = {\n        value: parseInt(includedQuotas[quotaKey].value, 10)\n      };\n    });\n\n    const varNames = Object.keys(scope);\n    const varValues = Object.values(scope);\n\n    const func = new Function(...varNames, `return ${formula};`);\n    return func(...varValues);\n  } catch (error) {\n    console.error('Error evaluating formula:', {\n      formula,\n      variables,\n      includedQuotas,\n      error\n    });\n    return 0;\n  }\n};\n\n// Calculate price for any pricing entity (plan or addon)\nexport const calculateEntityPrice = (entity, units) => {\n  // If no units are selected, the price is 0.\n  if (units === 0) {\n    return 0;\n  }\n\n  const variables = {\n    unit: units,\n    unit_price: parseFloat(entity.unit_price)\n  };\n  \n  // The formula might use a specific name for the unit, like 'seat' or 'resolution'\n  variables[entity.unit] = units;\n  \n  return evaluateFormula(entity.formula, variables, entity.included_quotas);\n};\n\n// Calculate total price including all selected addons\nexport const calculateTotalPrice = (selectedPlan, addons, planUnits, addonUnits) => {\n  let total = calculateEntityPrice(selectedPlan, planUnits[selectedPlan.id] || 0);\n  \n  addons.forEach(addon => {\n    if (addonUnits[addon.id] && addonUnits[addon.id] > 0) {\n      total += calculateEntityPrice(addon, addonUnits[addon.id]);\n    }\n  });\n  \n  return total;\n};\n\n// Get available addons for a specific plan\nexport const getAvailableAddons = (plan, allAddons) => {\n  return allAddons.filter(addon => \n    plan.available_addons && plan.available_addons.includes(addon.id)\n  );\n};\n\n// Validate pricing data against schema\nexport const validatePricingData = (data) => {\n  const requiredFields = ['vendor', 'url', 'currency', 'plans', 'addons'];\n  const missingFields = requiredFields.filter(field => !data[field]);\n  \n  if (missingFields.length > 0) {\n    throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n  }\n  \n  if (!Array.isArray(data.plans) || data.plans.length === 0) {\n    throw new Error('At least one plan is required');\n  }\n  \n  // Validate each plan\n  data.plans.forEach((plan, index) => {\n    const planRequiredFields = ['id', 'label', 'description', 'unit', 'unit_price', 'pricing_model', 'features', 'formula'];\n    const missingPlanFields = planRequiredFields.filter(field => !plan[field]);\n    \n    if (missingPlanFields.length > 0) {\n      throw new Error(`Plan ${index + 1} missing required fields: ${missingPlanFields.join(', ')}`);\n    }\n  });\n  \n  // Validate each addon\n  data.addons.forEach((addon, index) => {\n    const addonRequiredFields = ['id', 'label', 'description', 'unit', 'unit_price', 'pricing_model', 'features', 'formula'];\n    const missingAddonFields = addonRequiredFields.filter(field => !addon[field]);\n    \n    if (missingAddonFields.length > 0) {\n      throw new Error(`Addon ${index + 1} missing required fields: ${missingAddonFields.join(', ')}`);\n    }\n  });\n  \n  return true;\n};\n\n// Get default slider ranges based on pricing model and included quotas\nexport const getSliderRange = (entity) => {\n  const baseRange = { min: 0, max: 100, step: 1 };\n  \n  // Adjust range based on included quotas\n  if (entity.included_quotas) {\n    const quotaKey = Object.keys(entity.included_quotas)[0];\n    if (quotaKey && entity.included_quotas[quotaKey]) {\n      const quotaValue = parseInt(entity.included_quotas[quotaKey].value) || 0;\n      baseRange.max = Math.max(100, quotaValue + 50); // Extend range\n    }\n  }\n  \n  switch (entity.pricing_model) {\n    case 'per_unit':\n      return baseRange;\n    case 'flat':\n      return { min: 0, max: 1, step: 1 };\n    case 'tiered':\n      return { min: 1, max: 10, step: 1 };\n    default:\n      return baseRange;\n  }\n};\n\n// Format currency based on the provided currency code\nexport const formatCurrency = (amount, currency = 'USD') => {\n  const currencySymbols = {\n    'USD': '$',\n    'EUR': '€',\n    'GBP': '£',\n    'JPY': '¥',\n    'CAD': 'C$',\n    'AUD': 'A$'\n  };\n  \n  const symbol = currencySymbols[currency] || currency;\n  return `${symbol}${amount.toFixed(2)}`;\n};\n\n// Get included quota information for display\nexport const getIncludedQuotaInfo = (entity) => {\n  if (!entity.included_quotas) return null;\n  \n  const quotaKey = Object.keys(entity.included_quotas)[0];\n  if (quotaKey && entity.included_quotas[quotaKey]) {\n    const quota = entity.included_quotas[quotaKey];\n    return {\n      value: parseInt(quota.value) || 0,\n      unit: quota.unit || entity.unit\n    };\n  }\n  \n  return null;\n};\n\n// Check if current value is at the included quota level\nexport const isAtIncludedQuota = (entity, currentValue) => {\n  const quotaInfo = getIncludedQuotaInfo(entity);\n  if (!quotaInfo) return false;\n  \n  return currentValue <= quotaInfo.value;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}