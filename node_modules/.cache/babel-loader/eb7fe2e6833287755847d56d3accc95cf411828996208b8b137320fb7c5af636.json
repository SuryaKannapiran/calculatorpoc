{"ast":null,"code":"// Function to evaluate pricing formulas safely\nexport const evaluateFormula = (formula, variables) => {\n  try {\n    // Replace variables in the formula with their values\n    let evaluatedFormula = formula;\n    Object.keys(variables).forEach(key => {\n      const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n      evaluatedFormula = evaluatedFormula.replace(regex, variables[key]);\n    });\n\n    // Create a safe evaluation context with only allowed functions\n    const safeEval = expr => {\n      // Only allow basic mathematical operations and Math functions\n      const allowedFunctions = ['Math.max', 'Math.min', 'Math.round', 'Math.floor', 'Math.ceil'];\n      const allowedOperators = ['+', '-', '*', '/', '(', ')', '.', ' '];\n\n      // Basic validation - you might want to add more sophisticated validation\n      const hasOnlyAllowedChars = /^[0-9+\\-*/().\\s,]+$/.test(expr) || allowedFunctions.some(func => expr.includes(func));\n      if (!hasOnlyAllowedChars) {\n        throw new Error('Invalid characters in formula');\n      }\n\n      // Use Function constructor for safer evaluation\n      return new Function('Math', `return ${expr}`)(Math);\n    };\n    return safeEval(evaluatedFormula);\n  } catch (error) {\n    console.error('Error evaluating formula:', error);\n    return 0;\n  }\n};\n\n// Calculate price for any pricing entity (plan or addon)\nexport const calculateEntityPrice = (entity, units) => {\n  const variables = {\n    unit: units,\n    unit_price: parseFloat(entity.unit_price)\n  };\n  return evaluateFormula(entity.formula, variables);\n};\n\n// Calculate total price including all selected addons\nexport const calculateTotalPrice = (selectedPlan, addons, planUnits, addonUnits) => {\n  let total = calculateEntityPrice(selectedPlan, planUnits);\n  addons.forEach(addon => {\n    if (addonUnits[addon.id] && addonUnits[addon.id] > 0) {\n      total += calculateEntityPrice(addon, addonUnits[addon.id]);\n    }\n  });\n  return total;\n};\n\n// Get available addons for a specific plan\nexport const getAvailableAddons = (plan, allAddons) => {\n  return allAddons.filter(addon => plan.available_addons && plan.available_addons.includes(addon.id));\n};\n\n// Validate pricing data against schema\nexport const validatePricingData = data => {\n  const requiredFields = ['vendor', 'url', 'currency', 'plans', 'addons'];\n  const missingFields = requiredFields.filter(field => !data[field]);\n  if (missingFields.length > 0) {\n    throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n  }\n  if (!Array.isArray(data.plans) || data.plans.length === 0) {\n    throw new Error('At least one plan is required');\n  }\n\n  // Validate each plan\n  data.plans.forEach((plan, index) => {\n    const planRequiredFields = ['id', 'label', 'description', 'unit', 'unit_price', 'pricing_model', 'features', 'formula'];\n    const missingPlanFields = planRequiredFields.filter(field => !plan[field]);\n    if (missingPlanFields.length > 0) {\n      throw new Error(`Plan ${index + 1} missing required fields: ${missingPlanFields.join(', ')}`);\n    }\n  });\n\n  // Validate each addon\n  data.addons.forEach((addon, index) => {\n    const addonRequiredFields = ['id', 'label', 'description', 'unit', 'unit_price', 'pricing_model', 'features', 'formula'];\n    const missingAddonFields = addonRequiredFields.filter(field => !addon[field]);\n    if (missingAddonFields.length > 0) {\n      throw new Error(`Addon ${index + 1} missing required fields: ${missingAddonFields.join(', ')}`);\n    }\n  });\n  return true;\n};\n\n// Get default slider ranges based on pricing model\nexport const getSliderRange = entity => {\n  switch (entity.pricing_model) {\n    case 'per_unit':\n      return {\n        min: 0,\n        max: 100,\n        step: 1\n      };\n    case 'flat':\n      return {\n        min: 0,\n        max: 1,\n        step: 1\n      };\n    case 'tiered':\n      return {\n        min: 1,\n        max: 10,\n        step: 1\n      };\n    default:\n      return {\n        min: 0,\n        max: 100,\n        step: 1\n      };\n  }\n};\n\n// Format currency based on the provided currency code\nexport const formatCurrency = (amount, currency = 'USD') => {\n  const currencySymbols = {\n    'USD': '$',\n    'EUR': '€',\n    'GBP': '£',\n    'JPY': '¥',\n    'CAD': 'C$',\n    'AUD': 'A$'\n  };\n  const symbol = currencySymbols[currency] || currency;\n  return `${symbol}${amount.toFixed(2)}`;\n};","map":{"version":3,"names":["evaluateFormula","formula","variables","evaluatedFormula","Object","keys","forEach","key","regex","RegExp","replace","safeEval","expr","allowedFunctions","allowedOperators","hasOnlyAllowedChars","test","some","func","includes","Error","Function","Math","error","console","calculateEntityPrice","entity","units","unit","unit_price","parseFloat","calculateTotalPrice","selectedPlan","addons","planUnits","addonUnits","total","addon","id","getAvailableAddons","plan","allAddons","filter","available_addons","validatePricingData","data","requiredFields","missingFields","field","length","join","Array","isArray","plans","index","planRequiredFields","missingPlanFields","addonRequiredFields","missingAddonFields","getSliderRange","pricing_model","min","max","step","formatCurrency","amount","currency","currencySymbols","symbol","toFixed"],"sources":["/Users/cb-surya/work/personal_poc/calculatorpoc/src/utils/calculator.js"],"sourcesContent":["// Function to evaluate pricing formulas safely\nexport const evaluateFormula = (formula, variables) => {\n  try {\n    // Replace variables in the formula with their values\n    let evaluatedFormula = formula;\n    Object.keys(variables).forEach(key => {\n      const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n      evaluatedFormula = evaluatedFormula.replace(regex, variables[key]);\n    });\n    \n    // Create a safe evaluation context with only allowed functions\n    const safeEval = (expr) => {\n      // Only allow basic mathematical operations and Math functions\n      const allowedFunctions = ['Math.max', 'Math.min', 'Math.round', 'Math.floor', 'Math.ceil'];\n      const allowedOperators = ['+', '-', '*', '/', '(', ')', '.', ' '];\n      \n      // Basic validation - you might want to add more sophisticated validation\n      const hasOnlyAllowedChars = /^[0-9+\\-*/().\\s,]+$/.test(expr) || \n                                 allowedFunctions.some(func => expr.includes(func));\n      \n      if (!hasOnlyAllowedChars) {\n        throw new Error('Invalid characters in formula');\n      }\n      \n      // Use Function constructor for safer evaluation\n      return new Function('Math', `return ${expr}`)(Math);\n    };\n    \n    return safeEval(evaluatedFormula);\n  } catch (error) {\n    console.error('Error evaluating formula:', error);\n    return 0;\n  }\n};\n\n// Calculate price for any pricing entity (plan or addon)\nexport const calculateEntityPrice = (entity, units) => {\n  const variables = {\n    unit: units,\n    unit_price: parseFloat(entity.unit_price)\n  };\n  \n  return evaluateFormula(entity.formula, variables);\n};\n\n// Calculate total price including all selected addons\nexport const calculateTotalPrice = (selectedPlan, addons, planUnits, addonUnits) => {\n  let total = calculateEntityPrice(selectedPlan, planUnits);\n  \n  addons.forEach(addon => {\n    if (addonUnits[addon.id] && addonUnits[addon.id] > 0) {\n      total += calculateEntityPrice(addon, addonUnits[addon.id]);\n    }\n  });\n  \n  return total;\n};\n\n// Get available addons for a specific plan\nexport const getAvailableAddons = (plan, allAddons) => {\n  return allAddons.filter(addon => \n    plan.available_addons && plan.available_addons.includes(addon.id)\n  );\n};\n\n// Validate pricing data against schema\nexport const validatePricingData = (data) => {\n  const requiredFields = ['vendor', 'url', 'currency', 'plans', 'addons'];\n  const missingFields = requiredFields.filter(field => !data[field]);\n  \n  if (missingFields.length > 0) {\n    throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n  }\n  \n  if (!Array.isArray(data.plans) || data.plans.length === 0) {\n    throw new Error('At least one plan is required');\n  }\n  \n  // Validate each plan\n  data.plans.forEach((plan, index) => {\n    const planRequiredFields = ['id', 'label', 'description', 'unit', 'unit_price', 'pricing_model', 'features', 'formula'];\n    const missingPlanFields = planRequiredFields.filter(field => !plan[field]);\n    \n    if (missingPlanFields.length > 0) {\n      throw new Error(`Plan ${index + 1} missing required fields: ${missingPlanFields.join(', ')}`);\n    }\n  });\n  \n  // Validate each addon\n  data.addons.forEach((addon, index) => {\n    const addonRequiredFields = ['id', 'label', 'description', 'unit', 'unit_price', 'pricing_model', 'features', 'formula'];\n    const missingAddonFields = addonRequiredFields.filter(field => !addon[field]);\n    \n    if (missingAddonFields.length > 0) {\n      throw new Error(`Addon ${index + 1} missing required fields: ${missingAddonFields.join(', ')}`);\n    }\n  });\n  \n  return true;\n};\n\n// Get default slider ranges based on pricing model\nexport const getSliderRange = (entity) => {\n  switch (entity.pricing_model) {\n    case 'per_unit':\n      return { min: 0, max: 100, step: 1 };\n    case 'flat':\n      return { min: 0, max: 1, step: 1 };\n    case 'tiered':\n      return { min: 1, max: 10, step: 1 };\n    default:\n      return { min: 0, max: 100, step: 1 };\n  }\n};\n\n// Format currency based on the provided currency code\nexport const formatCurrency = (amount, currency = 'USD') => {\n  const currencySymbols = {\n    'USD': '$',\n    'EUR': '€',\n    'GBP': '£',\n    'JPY': '¥',\n    'CAD': 'C$',\n    'AUD': 'A$'\n  };\n  \n  const symbol = currencySymbols[currency] || currency;\n  return `${symbol}${amount.toFixed(2)}`;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}